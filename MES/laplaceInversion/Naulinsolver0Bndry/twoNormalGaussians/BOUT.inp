#
# Input file for  "NaulinSolver/twoNormalGaussians"
#
# x - The radial coordinate (rho)
# y - The height of the cylinder (z)
# z - The azimuthal coordinate (theta)

# Root options
###############################################################################
nout = 0            # Number of output timesteps
timestep = 1e-3     # Time between outputs

dump_format="nc"   # Write NetCDF format files

# Setting the z coordinate
ZMIN = 0.0
ZMAX = 1.0 # dz = 2*pi(ZMAX - ZMIN)/(MZ - 1)

# Number of guard cells
MXG = 1 # If this is changed the self implemented boundaries needs to change
MYG = 0 # If this is changed the self implemented boundaries needs to change

# Number of splittings in x
NXPE = 4
###############################################################################


# Mesh options
###############################################################################
[mesh]
# Number of points
nx = 4096 + 2*MXG
ny = 1
nz = 2^12
# The grid spacing
# As the points are located half between grid points, there will be as many
# line segments as points
# NOTE: We must divide by INNER POINTS (different definition of nx and ny)
dx = geom:Lx/(nx-2*MXG)
# The metrics
g33 = 1/(geom:xl^2)
J = geom:xl
# Puts the boundaries half a step outside the last gridpoints
symmetricGlobalY=true
symmetricGlobalX=true
# Position of the separatrix (-1 is non periodic, >ny is periodic)
# --------Non-periodic----------
ixseps1 = -1
ixseps2 = -1
# ------------------------------
###############################################################################


# Solver settings
###############################################################################
[solver]
# In principle it is the same what we set this to (as long as it doesn't raises
# error) as we here are not stepping forward in time)
# PVODE raises an error if no fields are being solved for
# Therefore set to euler solver which does not get this error
type = euler
###############################################################################


# Methods options
###############################################################################
# Methods used for the radial (x) derivative terms
[ddx]
first  = C2 # d/dx (f)
second = C2 # d^2/dx^2 (f)
upwind = U1 # u*d/dx (f)

#Methods used for the axial (y) derivative terms
[ddy]
first  = C2 # d/dy (f)
second = C2 # d^2/dy^2 (f)
upwind = U1 # u*d/dy (f)

#Methods used for the azimuthal (z) derivative terms
[ddz]
first  = FFT # d/dz (f)
second = FTT # d^2/dz^2 (f)
###############################################################################


# Specifying the output
###############################################################################
[output]
floats = false # floats = false => output in double
###############################################################################


# Settings for the variables
###############################################################################
# Geometry
# =============================================================================
[geom]
Lx = 30                     # The length of x from boundary to boundary
xl = x * geom:Lx            # x in range [0,Lx]
# =============================================================================


# The solver
# =============================================================================
[phiSolver]
# Inner boundary flag is set to be cylinder like (see the manual for the
# numbers)
inner_boundary_flags = 1024
# Outer boundary flag
# 0 - dirichlet 0 is used
outer_boundary_flags = 0
include_yguards = false # Do invert for the boundary cells
global_flags = 4        # Only one guard in the x boundary for inner and outer
# Options to the NaulinSolver
maxit = 800
# Set tolerances
atol = 1.0e-10
rtol = 1.0e-10
# Switches
NaulinMonitor = true
# =============================================================================


# The functions to test
# =============================================================================
# *****************************************************************************
[n]
function = 0.923116346386636*exp(-0.00222222222222222*geom:xl^2 + 0.0266666666666667*geom:xl*cos(z)) + 2

# Boundaries
bndry_xin   = none                      # Manual boundary found in the code
bndry_xout  = dirichlet_o4(n:function)
bndry_yup   = none                       # Since we are using 2D
bndry_ydown = none                       # Since we are using 2D
# *****************************************************************************

# *****************************************************************************
[phi]
function = 0.932102492359528*exp(-0.000868055555555556*geom:xl^2 - 0.015625*geom:xl*sin(z + pi/4))*cos(pi*geom:xl/60)

# Boundaries (needed here as we are taking derivatives)
bndry_xin   = none                      # Manual boundary found in the code
bndry_xout  = dirichlet_o4(phi:function)
bndry_yup   = none                       # Since we are using 2D
bndry_ydown = none                       # Since we are using 2D
# *****************************************************************************

[vortD]
# *****************************************************************************
function = 0.923116346386636*(-0.00444444444444444*geom:xl + 0.0266666666666667*cos(z))*(0.932102492359528*(-0.00173611111111111*geom:xl - 0.015625*sin(z + pi/4))*exp(-0.000868055555555556*geom:xl^2 - 0.015625*geom:xl*sin(z + pi/4))*cos(pi*geom:xl/60) - 0.0155350415393255*pi*exp(-0.000868055555555556*geom:xl^2 - 0.015625*geom:xl*sin(z + pi/4))*sin(pi*geom:xl/60))*exp(-0.00222222222222222*geom:xl^2 + 0.0266666666666667*geom:xl*cos(z)) + (0.923116346386636*exp(-0.00222222222222222*geom:xl^2 + 0.0266666666666667*geom:xl*cos(z)) + 2)*((0.932102492359528*(0.00173611111111111*geom:xl + 0.015625*sin(z + pi/4))^2*cos(pi*geom:xl/60) + 0.0310700830786509*pi*(0.00173611111111111*geom:xl + 0.015625*sin(z + pi/4))*sin(pi*geom:xl/60) - 0.000258917358988758*pi^2*cos(pi*geom:xl/60) - 0.00161823349367974*cos(pi*geom:xl/60))*exp(-geom:xl*(0.000868055555555556*geom:xl + 0.015625*sin(z + pi/4))) + (0.000227564085048713*geom:xl*cos(z + pi/4)^2 + 0.0145641014431176*sin(z + pi/4))*exp(-geom:xl*(0.000868055555555556*geom:xl + 0.015625*sin(z + pi/4)))*cos(pi*geom:xl/60)/geom:xl + (0.932102492359528*(-0.00173611111111111*geom:xl - 0.015625*sin(z + pi/4))*exp(-0.000868055555555556*geom:xl^2 - 0.015625*geom:xl*sin(z + pi/4))*cos(pi*geom:xl/60) - 0.0155350415393255*pi*exp(-0.000868055555555556*geom:xl^2 - 0.015625*geom:xl*sin(z + pi/4))*sin(pi*geom:xl/60))/geom:xl) + 0.000358516269668668*exp(-0.00222222222222222*geom:xl^2 + 0.0266666666666667*geom:xl*cos(z))*exp(-0.000868055555555556*geom:xl^2 - 0.015625*geom:xl*sin(z + pi/4))*sin(z)*cos(pi*geom:xl/60)*cos(z + pi/4)

# No boundary condition needed as no derivatives are being taken of this
# *****************************************************************************
# =============================================================================
##############################################################################
