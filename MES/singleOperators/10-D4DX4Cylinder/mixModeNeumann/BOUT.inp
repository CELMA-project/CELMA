#
# Input file for  "D4DX4Cylinder/mixModeNeumann"
#
# x - The radial coordinate (rho)
# y - The height of the cylinder (z)
# z - The azimuthal coordinate (theta)

# Root options
###############################################################################
nout = 0            # Number of output timesteps
timestep = 1e-3     # Time between outputs

dump_format="nc"   # Write NetCDF format files

# Setting the z coordinate
ZMIN = 0.0
ZMAX = 1.0 # dz = 2*pi(ZMAX - ZMIN)/(MZ - 1)

# Number of guard cells
MXG = 1 # If this is changed the self implemented boundaries needs to change
MYG = 0 # Make this 2D

# Number of splittings in x
NXPE = 4
###############################################################################


# Mesh options
###############################################################################
[mesh]
# Number of points
nx = 4096 + 2*MXG
ny = 1
nz = 2^8
# The grid spacing
# As the points are located half between grid points, there will be as many
# line segments as points
# NOTE: We must divide by INNER POINTS (different definition of nx and ny)
dx = geom:Lx/(nx-2*MXG)
# The metrics
g33 = 1/(geom:xl^2)
J = geom:xl
# Puts the boundaries half a step outside the last gridpoints
symmetricGlobalY=true
symmetricGlobalX=true
# Position of the separatrix 
# Points 0 <= x < ixseps1 are inside separatrix, ixseps1 <= x < ngx outside
# --------Non-periodic----------
ixseps1 = -1
ixseps2 = -1
# ------------------------------
###############################################################################


# Solver settings
###############################################################################
[solver]
# In principle it is the same what we set this to (as long as it doesn't raises
# error) as we here are not stepping forward in time)
# PVODE raises an error if no fields are being solved for
# Therefore set to euler solver which does not get this error
type = euler
###############################################################################


# Methods options
###############################################################################
# Methods used for the radial (x) derivative terms
[ddx]
first  = C2 # d/dx (f)
second = C2 # d^2/dx^2 (f)
upwind = U1 # u*d/dx (f)

#Methods used for the axial (y) derivative terms
[ddy]
first  = C2 # d/dy (f)
second = C2 # d^2/dy^2 (f)
upwind = U1 # u*d/dy (f)

#Methods used for the azimuthal (z) derivative terms
[ddz]
first  = FFT # d/dz (f)
second = FTT # d^2/dz^2 (f)
###############################################################################


# Specifying the output
###############################################################################
[output]
floats = false # floats = false => output in double
###############################################################################


# Switches
###############################################################################
[switch]
# Give a warning rather than throwing error when insufficient number of points
warnPoints = true
###############################################################################


# Settings for the variables
###############################################################################
# Geometry
# =============================================================================
[geom]
Lx = 30                     # The length of x from boundary to boundary
xl = x * geom:Lx            # x in range [0,Lx]
# =============================================================================


# The function to test
# =============================================================================
[f]
function = 6.85871056241427e-10*geom:xl^6*(-tanh(0.125*geom:xl - 1.25) + 1)*(sin(pi*geom:xl/15) + 3*cos(pi*geom:xl/15) + 2*cos(2*pi*geom:xl/15) + cos(pi*geom:xl/5))*cos(2*z) + 6
neumann = 6.85871056241427e-10*geom:xl^6*(-tanh(0.125*geom:xl - 1.25) + 1)*(-pi*sin(pi*geom:xl/15)/5 - 4*pi*sin(2*pi*geom:xl/15)/15 - pi*sin(pi*geom:xl/5)/5 + pi*cos(pi*geom:xl/15)/15)*cos(2*z) + 6.85871056241427e-10*geom:xl^6*(0.125*tanh(0.125*geom:xl - 1.25)^2 - 0.125)*(sin(pi*geom:xl/15) + 3*cos(pi*geom:xl/15) + 2*cos(2*pi*geom:xl/15) + cos(pi*geom:xl/5))*cos(2*z) + 4.11522633744856e-9*geom:xl^5*(-tanh(0.125*geom:xl - 1.25) + 1)*(sin(pi*geom:xl/15) + 3*cos(pi*geom:xl/15) + 2*cos(2*pi*geom:xl/15) + cos(pi*geom:xl/5))*cos(2*z)

# Boundaries
bndry_xin   = none                     # Manual boundary found in the code
bndry_xout  = neumann_o4(f:neumann)
bndry_yup   = none                     # Not used
bndry_ydown = none                     # Not used
# =============================================================================


# The analytic solution
# =============================================================================
[S]
solution = geom:xl^2*(-1.35480702467442e-14*pi^4*geom:xl^4*(tanh(0.125*geom:xl - 1.25) - 1)*(sin(pi*geom:xl/15) + 3*cos(pi*geom:xl/15) + 32*cos(2*pi*geom:xl/15) + 81*cos(pi*geom:xl/5)) - 2.67918381344307e-12*geom:xl^4*(tanh(0.125*geom:xl - 1.25)^2 - 1)^2*(sin(pi*geom:xl/15) + 3*cos(pi*geom:xl/15) + 2*cos(2*pi*geom:xl/15) + cos(pi*geom:xl/5))*tanh(0.125*geom:xl - 1.25) - 7.14449016918153e-13*pi*geom:xl^4*(tanh(0.125*geom:xl - 1.25)^2 - 1)^2*(3*sin(pi*geom:xl/15) + 4*sin(2*pi*geom:xl/15) + 3*sin(pi*geom:xl/5) - cos(pi*geom:xl/15)) - 1.33959190672154e-12*geom:xl^4*(tanh(0.125*geom:xl - 1.25)^2 - 1)*(sin(pi*geom:xl/15) + 3*cos(pi*geom:xl/15) + 2*cos(2*pi*geom:xl/15) + cos(pi*geom:xl/5))*tanh(0.125*geom:xl - 1.25)^3 + 5.71559213534522e-13*pi^2*geom:xl^4*(tanh(0.125*geom:xl - 1.25)^2 - 1)*(sin(pi*geom:xl/15) + 3*cos(pi*geom:xl/15) + 8*cos(2*pi*geom:xl/15) + 9*cos(pi*geom:xl/5))*tanh(0.125*geom:xl - 1.25) - 1.42889803383631e-12*pi*geom:xl^4*(tanh(0.125*geom:xl - 1.25)^2 - 1)*(3*sin(pi*geom:xl/15) + 4*sin(2*pi*geom:xl/15) + 3*sin(pi*geom:xl/5) - cos(pi*geom:xl/15))*tanh(0.125*geom:xl - 1.25)^2 + 1.01610526850582e-13*pi^3*geom:xl^4*(tanh(0.125*geom:xl - 1.25)^2 - 1)*(3*sin(pi*geom:xl/15) + 16*sin(2*pi*geom:xl/15) + 27*sin(pi*geom:xl/5) - cos(pi*geom:xl/15)) - 4.87730528882792e-12*pi^3*geom:xl^3*(tanh(0.125*geom:xl - 1.25) - 1)*(3*sin(pi*geom:xl/15) + 16*sin(2*pi*geom:xl/15) + 27*sin(pi*geom:xl/5) - cos(pi*geom:xl/15)) + 6.43004115226338e-11*geom:xl^3*(tanh(0.125*geom:xl - 1.25)^2 - 1)^2*(sin(pi*geom:xl/15) + 3*cos(pi*geom:xl/15) + 2*cos(2*pi*geom:xl/15) + cos(pi*geom:xl/5)) + 1.28600823045268e-10*geom:xl^3*(tanh(0.125*geom:xl - 1.25)^2 - 1)*(sin(pi*geom:xl/15) + 3*cos(pi*geom:xl/15) + 2*cos(2*pi*geom:xl/15) + cos(pi*geom:xl/5))*tanh(0.125*geom:xl - 1.25)^2 - 2.74348422496571e-11*pi^2*geom:xl^3*(tanh(0.125*geom:xl - 1.25)^2 - 1)*(sin(pi*geom:xl/15) + 3*cos(pi*geom:xl/15) + 8*cos(2*pi*geom:xl/15) + 9*cos(pi*geom:xl/5)) + 1.02880658436214e-10*pi*geom:xl^3*(tanh(0.125*geom:xl - 1.25)^2 - 1)*(3*sin(pi*geom:xl/15) + 4*sin(2*pi*geom:xl/15) + 3*sin(pi*geom:xl/5) - cos(pi*geom:xl/15))*tanh(0.125*geom:xl - 1.25) + 5.48696844993141e-10*pi^2*geom:xl^2*(tanh(0.125*geom:xl - 1.25) - 1)*(sin(pi*geom:xl/15) + 3*cos(pi*geom:xl/15) + 8*cos(2*pi*geom:xl/15) + 9*cos(pi*geom:xl/5)) - 3.85802469135803e-9*geom:xl^2*(tanh(0.125*geom:xl - 1.25)^2 - 1)*(sin(pi*geom:xl/15) + 3*cos(pi*geom:xl/15) + 2*cos(2*pi*geom:xl/15) + cos(pi*geom:xl/5))*tanh(0.125*geom:xl - 1.25) - 2.05761316872428e-9*pi*geom:xl^2*(tanh(0.125*geom:xl - 1.25)^2 - 1)*(3*sin(pi*geom:xl/15) + 4*sin(2*pi*geom:xl/15) + 3*sin(pi*geom:xl/5) - cos(pi*geom:xl/15)) + 2.19478737997257e-8*pi*geom:xl*(tanh(0.125*geom:xl - 1.25) - 1)*(3*sin(pi*geom:xl/15) + 4*sin(2*pi*geom:xl/15) + 3*sin(pi*geom:xl/5) - cos(pi*geom:xl/15)) + 4.11522633744856e-8*geom:xl*(tanh(0.125*geom:xl - 1.25)^2 - 1)*(sin(pi*geom:xl/15) + 3*cos(pi*geom:xl/15) + 2*cos(2*pi*geom:xl/15) + cos(pi*geom:xl/5)) - 2.46913580246914e-7*(tanh(0.125*geom:xl - 1.25) - 1)*(sin(pi*geom:xl/15) + 3*cos(pi*geom:xl/15) + 2*cos(2*pi*geom:xl/15) + cos(pi*geom:xl/5)))*cos(2*z)
# =============================================================================
##############################################################################
